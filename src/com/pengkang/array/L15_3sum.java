//3sum
//
//首先对数组进行排序，排序后固定一个数 nums[i]nums[i]，再使用左右指针指向 nums[i]nums[i]后面的两端，数字分别为 nums[L]nums[L] 和 nums[R]nums[R]，计算三个数的和 sumsum 判断是否满足为 00，满足则添加进结果集
//如果 nums[i]nums[i]大于 00，则三数之和必然无法等于 00，结束循环
//如果 nums[i]nums[i] == nums[i-1]nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过
//当 sumsum == 00 时，nums[L]nums[L] == nums[L+1]nums[L+1] 则会导致结果重复，应该跳过，L++L++
//当 sumsum == 00 时，nums[R]nums[R] == nums[R-1]nums[R−1] 则会导致结果重复，应该跳过，R--R−−
//时间复杂度：O(n^2)O(n
//2)，nn 为数组长度
//
//
//class Solution15 {
//    public List<List<Integer>> threeSum(int[] nums) {
//        //用hash set 去重
//
//        Set<List<Integer>> res  = new HashSet<>();
//        if(nums.length==0) return new ArrayList<>(res);
//        Arrays.sort(nums);
//        for(int i=0; i<nums.length-2;i++){
//            int j =i+1;
//           int  k = nums.length-1;
//            while(j<k){
//                int sum = nums[i]+nums[j]+nums[k];
//                if(sum==0)res.add(Arrays.asList(nums[i],nums[j++],nums[k--]));
//                else if ( sum >0) k--;
//                else if (sum<0) j++;
//            }
//
//        }
//        return new ArrayList<>(res);
//    }
//}
//
//a遍历O(N)里嵌套b遍历O(N)再嵌套c,d双指针O(N)--> O(N^3)。 总比暴力法O(N^4)好些吧。
//
//四数之和与前面三数之和的思路几乎是一样的，嗝。（刚好前些天才写了三数之和的题解）
// 如果前面的三数之和会做了的话，这里其实就是在前面的基础上多添加一个遍历的指针而已。
// 会做三数之和的可以不用看下面的了。。
//
// 使用四个指针(a<b<c<d)。固定最小的a和b在左边，c=b+1,d=_size-1 移动两个指针包夹求解。
// 保存使得nums[a]+nums[b]+nums[c]+nums[d]==target的解。偏大时d左移，偏小时c右移。c和d相
// 遇时，表示以当前的a和b为最小值的解已经全部求得。b++,进入下一轮循环b循环，当b循环结束后。
// a++，进入下一轮a循环。 即(a在最外层循环，里面嵌套b循环，再嵌套双指针c,d包夹求解)。
//
//for(a=0;a<=_size-4;a++){
//        	if(a>0&&nums[a]==nums[a-1]) continue;      //确保nums[a] 改变了
//        	for(b=a+1;b<=_size-3;b++){
//        		if(b>a+1&&nums[b]==nums[b-1])continue;   //确保nums[b] 改变了
//        		c=b+1,d=_size-1;
//        		while(c<d){
//        			if(nums[a]+nums[b]+nums[c]+nums[d]<target)
//        			    c++;
//        			else if(nums[a]+nums[b]+nums[c]+nums[d]>target)
//        			    d--;
//        			else{
//        				res.push_back({nums[a],nums[b],nums[c],nums[d]});
//        				while(c<d&&nums[c+1]==nums[c])      //确保nums[c] 改变了
//        				    c++;
//        				while(c<d&&nums[d-1]==nums[d])      //确保nums[d] 改变了
//        				    d--;
//        				c++;
//        				d--;
//					}
//				}
//			}
//		}
//
